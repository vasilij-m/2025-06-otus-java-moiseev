# Определение нужного размера хипа
ДЗ к занятию 8

Цель: на примере простого приложения понять, какое влияние оказывают сборщики мусора.

## Задание:
Есть готовое приложение (calculator).  
1. Запустите его с размером хипа 256 Мб и посмотрите в логе время выполнения.  
   Пример вывода:
   ```
   spend msec:18284, sec:18
   ```
2. Увеличьте размер хипа до 2 Гб (с шагом в 256 Мб), замерьте время выполнения.  
   Результаты запусков записывайте в таблицу.
3. Определите оптимальный размер хипа, т.е. размер, превышение которого, не приводит к сокращению времени выполнения приложения.
4. Оптимизируйте работу приложения.  
   Т.е. не меняя логики работы, сделайте так, чтобы приложение работало быстро с минимальным хипом.
5. Повторите измерения времени выполнения программы для тех же значений размера хипа.

## Результаты измерений
В таблице приведена зависимость показателя `spend sec` (время, за которое программа выдаёт конечный результат) от размера кучи (параметры JVM `Xms/Xmx`)

| Xms/Xmx       | До оптимизации | 1я оптимизация | 2я оптимизация | 3я оптимизация | 4я оптимизация |
| ------------- | -------------- | -------------- | -------------- | -------------- | -------------- |
| 16m/16m       | 117            | 49             | 46             | 40             | 4              |
| 32m/32m       | 89             | 43             | 39             | 39             | 4              |
| 64m/64m       | 80             | 41             | 41             | 38             | 4              |
| 128m/128m     | 78             | 42             | 38             | 40             | 4              |
| 256m/256m     | 72             | 40             | 37             | 35             | 4              |
| 512m/512m     | 69             | 35             | 37             | 34             | 4              |
| 768m/768m     | 67             | 38             | 34             | 36             | 4              |
| 1024m/1024m   | 67             | 39             | 36             | 35             | 4              |
| 1280m/1280m   | 70             | 37             | 33             | 35             | 4              |
| 1536m/1536m   | 69             | 37             | 34             | 36             | 4              |
| 1792m/1792m   | 68             | 36             | 34             | 36             | 4              |
| 2048m/2048m   | 63             | 37             | 35             | 35             | 4              |
| 4096m/4096m   | 61             | 35             | 35             | 34             | 4              |
| 8192m/8192m   | 56             | 37             | 36             | 36             | 4              |
| 16384m/16384m | 44             | 37             | 36             | 38             | 4              |

### Оптимизация
1. Замена `Integer` на `int` в полях и методах классов `Summator` и `Data`
2. Так как в классе `Summator` есть обращение только к текущему объекту `Data`, который передаётся на вход метода `calc(Data data)`, то неважно, какие именно элементы лежат в коллекции `List<Data> listValues`. А значит, на вход метода `calc(Data data)` можно передавать один и тот же объект, но каждый раз меняя его поле `value`.  
   Для этой оптимизации у поля `value` класса `Data` убрал модификатор `final`, и добавил сеттер для установки его значения. И в `main` методе класса `CalcDemo` объект `Data` создаётся до основного цикла, а в цикле с помощью сеттера лишь меняется значение поля `value`. Но по результатам замеров эта оптимизация показала незначительные улучшения только при некоторых значениях Xms/Xmx.  
   Также пробовал преобразовать класс `Data` в `record`, но результаты оказались немного хуже, чем переиспользование одного и того же объекта `Data`.
3. В классе `Summator` происходит очистка списка `listValues`, как только он достигнет размера в 100 тысяч элементов. Значит, имеет смысл сразу инициализировать этот список с ёмкостью в 100 тысяч элементов. Для этого я создал в классе `Summator` константу `CAPACITY` и использую её при создании списка `listValues`.  
   Также сместил добавление элемента в список после блока условия для его очистки, чтобы не произошло его расширение при добавлении 100 тысяч первого элемента. Но по результатам замеров эта оптимизация показала незначительные улучшения только при значении `Xms/Xmx` `16m/16m`.
4. Заменил использование избыточного `java.security.SecureRandom` на `java.util.Random`.

## Выводы
1. До оптимизации увеличение размера кучи всегда приводило к ускорению работы программы
2. Замена классов обёрток (Integer на int) уменьшило время выполнения в два раза, но увеличение размера кучи сверх 512m не приводило к ускорению программы
3. Инициализация ArrayList с указанием его ёмкости привело к незначительному уменьшению времени выполнения программы только при минимальном размере кучи в 16m, при остальных значениях результаты в аналогичны предыдущей оптимизацией
4. Замена использования `java.security.SecureRandom` на `java.util.Random` снизило время выполнения программы до 4 секунд для всех значений размера кучи